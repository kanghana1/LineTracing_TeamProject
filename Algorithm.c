#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          lm,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          rm,	    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#define MAX_POINTS 100 // max points
#define MAX_DISTANCE 1000000000 // max distance
#define INF 987654321


typedef struct Point {
   int r;
   int c;
} Point;

Point currentPoint = {0, 0}; // 현재 위치
Point FinishPoint = {0, 0};
Point redPoint; // 최단거리 레드패치 찾는 걸로 초기화를 해줘야함
int redCount = 0;
int Qmap[5][5];
int colorMapping[5][5]; // 본래맵
// int redPatchMap[5][5]; // 레드패치맵

/*
float Calculate(Point point1, Point point2){ // calculating distance
   return abs((point1.r + point1.c) - (point2.r + point2.c));
}

int min(int a, int b)
{
   return a < b ? a : b;
}


int max(int a, int b)
{
   return a > b ? a : b;
}

Point minPoint(Point point1, Point point2) {
   Point result;
   result.r = min(point1.r, point2.r);
   result.c = min(point1.c, point2.c);
   return result;
}

Point maxPoint(Point point1, Point point2) {
   Point result;
   result.r = max(point1.r, point2.r);
   result.c = max(point1.c, point2.c);
   return result;
}


Point findShortestDistance(Point currentPosition, Point redPoint[], int redPointCount){ // send redPoint array. compare each elements
	float shortestDistance = MAX_DISTANCE;
	Point shortest_redPatch;

	for (int i = 0; i < redPointCount; i++){
		float distance = Calculate(currentPosition, redPoint[i]);
		if (distance <= shortestDistance) {
			shortestDistance = distance;
			shortest_redPatch.r = redPoint[i].r;
			shortest_redPatch.c = redPoint[i].c;
		}
	}

	return shortest_redPatch; // it returns shortest_redPatch location x, y
}
*/

bool isPointZero(Point point){ // judging, is it 0, 0.
   return (point.r == 0 && point.c == 0);
}

// int isSafe(int row, int col, int array[5][5], int visited[5][5]) { // 갈 수 있는 곳인지 판별하는 함수
//     return (row >= 0) && (row < 5) && (col >= 0) && (col < 5) && // 좌표가 범위 내에 있고,
//            (array[row][col] != -1) && !visited[row][col]; // 장애물(-1)이 없는지
// }

float oneQmap(Point p1) { // 예를 들어 레드포인트가 0,1 일 떄
	float QMap[5][5]; // 큐맵 중 한 개

	for (int i = 0 ; i < 5 ; i++) { // 파란점 외에는 0으로 초기화
		for (int j = 0 ; j < 5 ; j++) {
			if (colorMapping[i][j] == -1) QMap[i][j] = -1; 
			else QMap[i][j] = 0;
		}
	}
	Qmap[p1.r][p1.c] = 1; // 레드포인트 한 개만 넣기

	for (int i = 0 ; i < 5 ; i++) {
		for (int j = 0 ; j < 5 ; j++) {
			if (QMap[i][j] == 0) { 
				if (abs(p1.r - i) + abs(p1.c - j) == 1) {
					QMap[i][j] = 0.9;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 2) {
					QMap[i][j] = 0.72;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 3) {
					QMap[i][j] = 0.5;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 4) {
					QMap[i][j] = 0.3;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 5) {
					QMap[i][j] = 0.15;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 6) {
					QMap[i][j] = 0.06;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 7) {
					QMap[i][j] = 0.02;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 8) {
					QMap[i][j] = 0.004;
				}
			}
		}
	}
	return QMap;
}

// Q sum method.
void sumQmap(Point redP)
{
   for(int i=0; i<redCount; i++) // 레드패치 수만큼 반복
   {
      float arrayQ[5][5] = oneQmap(redP);
      for(int j=0; j<5; j++) // 토탈 Q 맵에 모든 레드패치맵 값 더하기
      {
         for(int k=0; k<5; k++)
         {
            Qmap[j][k] += arrayQ[j][k];
         }
      }
   }
}







// This method calculates the weight from the current location to the red patch located
//  at the shortest distance to helps the robot achieve optimal movement.

int findDt(Point start, Point end, int arr[5][5])
{ // !! S: information about the patch, Dt: information about weights.

   Point Small, Large;
   int Small_r, Small_c, Large_r, Large_c;
   
   Small = minPoint(start, end); // (자른 배열의 시작지점 구하기)
   Large = maxPoint(start, end); // (자른 배열의 끝지점 구하기)

   Small_r = Small.r;
   Small_c = Small.c;
   Large_r = Large.r;
   Large_c = Large.c;

   Point array_Start = {Small_r, Small_c}; // start point of the original array (본래 배열의 시작지점)
   Point array_End = {Large_r, Large_c}; // end point of the original array (본래 배열의 끝지점)

   int size_r = abs(start.r - end.r) + 1; // array r_size (자른 배열의 r사이즈)
   int size_c = abs(start.c - end.c) + 1; // array c_size (자른 배열의 c사이즈)

   int smallDt[size_r][size_c]; // define small_array of Dt (가중치 배열인 Dt 선언)
   int smallS[size_r][size_c]; // define small_array of S (패치의 위치 배열인 S 선언)

   for (int i = 0; i < size_r; i++) // Bring the patch of original array. In smallS
   {                                // (smallS에다가 자른 배열만큼에 해당하는 본래의 패치 정보를 불러옴)
      for (int j = 0; j < size_c; j++)
      {
         smallS[i][j] = arr[array_Start.r + i][array_Start.c + j]; // 본래의 배열에서 시작지점부터 불러옴
      }
   }


   if(start.r > end.r && start.c > end.c) // direction Left and Up (왼쪽, 위 이동할때의 가중치계산)
   {
      for(int i=start.r; i>=end.r; i--) // Weight calculation about small array.
	   {
		   for(int j=start.c; j>=end.c; j--)
			   {
			   if(i==start.r && j==start.c) smallDt[i][j] = smallS[i][j];
			   else if(i==start.r) smallDt[i][j] = smallDt[i][j+1] + smallS[i][j]; // 왼쪽 방향 가중치
			   else if(j==start.c) smallDt[i][j] = smallDt[i+1][j] + smallS[i][j]; // 위쪽방향 가중치
			   else smallDt[i][j] = max(smallDt[i+1][j], smallDt[i][j+1]) + smallS[i][j];
		   	}
	   }
   }
   else if(start.r > end.r) // direction Up and... (위쪽으로 이동할 건데..)
   {
      if(start.c < end.c) // direction Up and Right (오른쪽으로도 갈 때의 가중치 계산)
      {
         for(int i=start.r; i>=end.r; i--)
	      {
		      for(int j=start.c; j<=end.c; j++)
			      {
			      if(i==start.r && j==start.c) smallDt[i][j] = smallS[i][j];
			      else if(i==start.r) smallDt[i][j] = smallDt[i][j-1] + smallS[i][j]; // 오른쪽 방향 가중치
			      else if(j==start.c) smallDt[i][j] = smallDt[i+1][j] + smallS[i][j]; // 위쪽 방향 가중치
			      else smallDt[i][j] = max(smallDt[i+1][j], smallDt[i][j-1]) + smallS[i][j];
		   	   }
	      }
      }
      else // start.c==end.c. because of (start.r > end.r) is included Left and Up. direction Up.
      {    // (이건 무조건 start.c==end.c. (start.c > end.c)는 이미 위 if문에 (왼쪽, 위) 이동에 포함되어있기 때문. 위쪽으로만의 가중치 계산)
         for(int i=start.r; i>=end.r; i--)
	      {
		      for(int j=start.c; j<=end.c; j--)
			      {
			      if(i==start.r && j==start.c) smallDt[i][j] = smallS[i][j];
			      else smallDt[i][j] = smallDt[i+1][j] + smallS[i][j];
		   	   }
	      }
      }
   }
   else if(start.r < end.r) // direction down and Left (아래로 가면서 왼쪽으로 갈 때의 가중치 계산)
   {                        // 오른쪽만 가거나, 아래만 가거나, (오른쪽, 아래)로 가는 경우의 수는 존재할 수 없다.
      for(int i=start.r; i<=end.r; i++) // Weight calculation about small array.
	   {
		   for(int j=start.c; j>=end.c; j--)
			   {
			   if(i==start.r && j==start.c) smallDt[i][j] = smallS[i][j];
			   else if(i==start.r) smallDt[i][j] = smallDt[i][j+1] + smallS[i][j]; // 왼쪽 방향 가중치
			   else if(j==start.c) smallDt[i][j] = smallDt[i-1][j] + smallS[i][j]; // 아래쪽 방향 가중치
			   else smallDt[i][j] = max(smallDt[i-1][j], smallDt[i][j+1]) + smallS[i][j];
		   	}
	   }
   }
   else // start.r == end.r direction Left (왼쪽으로만 갈 때의 가중치 계산)
   {
      for(int i=start.r; i>=end.r; i--) // Weight calculation about small array.
	   {
		   for(int j=start.c; j>=end.c; j--)
			   {
			   if(i==start.r && j==start.c) smallDt[i][j] = smallS[i][j];
			   else smallDt[i][j] = smallDt[i][j+1] + smallS[i][j];
		   	}
	   }
   }


   if (smallDt[end.r][end.c] > 0) // (도착지점의 가중치가 양수면 배열 반환)
   {
      return smallDt; // return an array of weights to go from (start point) to (end point)
   }
   else if(smallDt[end.r][end.c] == 0)
   {
      return 1; // 1인 이유는 main에서 설명
   }
   else
   {
      return 0; // False. Don't visit this redPatch
   }
}




void gotoNextRedpatch(int dt[5][5], Point start_p, Point end_p)
{
   int start_r = start_p.r;
   int start_c = start_p.c;
   int end_r = end_p.r;
   int end_c = end_p.c;

   while(start_r != end_r && start_c != end_c)
	{
      if(start_r > end_r && start_c > end_c) // move (left)+(up)
      {
         if(dt[start_r-1][start_c] > dt[start_r][start_c-1]) // Left is bigger than Up
         {
            start_c -= 1; // goLeft
            // 왼쪽으로 이동하는 함수 부르기
         }
         else if(dt[start_r-1][start_c] < dt[start_r][start_c-1]) // Up is bigger than Left
         {
            start_r -= 1; // goUp
            // 위쪽으로 이동하는 함수 부르기
         }
         else // if (Left, Up) is same?????
         {
            start_c -= 1; // goLeft
            // 왼쪽으로 이동하는 함수 부르기
         }
      }
		else if(start_r > end_r) // move Up... 위쪽으로 갈 건데...
      {
         if(start_c < end_c) // 오른쪽으로 가야하면
         {
            if(dt[start_r-1][start_c] < dt[start_r][start_c+1]) // 오른쪽 이동
            {
               start_c += 1; // goRight
               // 오른쪽으로 이동하는 함수 부르기
            }
            else if(dt[start_r-1][start_c] > dt[start_r][start_c+1]) // 위쪽 이동
            {
               start_r -= 1; // goUp
               // 위쪽으로 이동하는 함수 부르기
            }
            else
            {
               start_c += 1; // goRight
               // 오른쪽으로 이동하는 함수 부르기
            }
         }
         else
         {
            start_r -= 1; // goUp
         }
      }
      else if(start_r < end_r) // 왼쪽 아래로
      {
         if(dt[start_r-1][start_c] > dt[start_r][start_c-1])
         {
            start_c -= 1; // goLeft
            // 왼쪽으로 이동하는 함수 부르기
         }
         else if(dt[start_r-1][start_c] < dt[start_r][start_c+1])
         {
            start_r += 1; // goRight
            // 오른쪽으로 이동하는 함수 부르기
         }
      }
      else // 왼쪽으로만
      {
         start_c -= 1;
         // 왼쪽으로 이동하는 함수 부르기
      }

		eraseDisplay();

	}
}

Point RightUpredPatch() // 맨오른쪽아래 빨간점 위치 반환
{
   Point redlast = {-1, -1};
   for (int i = 0; i < 5; ++i) {
      for (int j = 0; j < 5; ++j) {
         if (redPatchMap[i][j] == 1) { // 마지막 빨간점의 인덱스 찾기
            redlast.r = i;
            redlast.c = j;
         }
      }
   }
   return redlast;
}

int redisIn()
{
   int cnt = 0;
   for(int i=0; i<5; i++)
   {
      for(int j=0; j<5; j++)
      {
         if(colorMapping[i][j] == 1)
         {
            cnt += 1;
         }
      }
   }
   return cnt;
}

task main()
{
   int mapsize_r = 0, mapsize_c = 0;
   int k = 0;
   Point redPatch[redCount];

   for (int i = 0; i < 5; ++i) {
      for (int j = 0; j < 5; ++j) {
         if (colorMapping[i][j] == 1) { // 컬러맵에서 1이 있으면 그 위치에 똑같이 레드패치맵에 1넣기
            redPatchMap[i][j] = 1;
            redPatch[k].r = i;
            redPatch[k].c = j;
            k += 1;
         }
      }
   }


   for (int i=0; i<redCount; i++)
   {
      sumQmap(redPatch[i]);
   }

/*
   while(currentPoint.r != 0 && currentPoint.c != 0)
   {
      if(redCount == 0) // 레드패치수가 0개면
      {
         mapsize_r = abs(currentPoint.r- FinishPoint.r) + 1;
         mapsize_c = abs(currentPoint.c- FinishPoint.c) + 1;
         int arr[mapsize_r][mapsize_c] = findDt(currentPoint, FinishPoint, colorMapping); // 오류 안 나나??
         gotoNextRedpatch(arr, currentPoint, FinishPoint);
      }
      else if(redCount > 0) // 레드패치수가 0보다 크면
      {
         redPoint = findShortestDistance(currentPoint, redPatch, redCount); // 다음 레드패치 위치 구하기
         if (redisIn() == 0) // 만약 패치수는 많은데, 맵에 1이 없다면?
         {
            Point RightUpredPoint = RightUpredPatch(); // 맨오른쪽아래 레드패치지점
         }
         else if(findDt(currentPoint, redPoint, colorMapping) == 0) // 반환값이 0이면(가중치가 음수)
         {
            colorMapping[redPoint.r][redPoint.c] = -1; // 패치맵에서 빨간지점 패치값 -1로 변경
            redPatchMap[redPoint.r][redPoint.c] = 0; // 레드 패치맵에서 그 지점 패치값 없애기
            k -= 1;
         }
         else if(findDt(currentPoint, redPoint, colorMapping) == 1) // 반환값이 1이면(가중치가 0)
         {
            colorMapping[redPoint.r][redPoint.c] = 0; // 패치맵에서 빨간지점 패치값 0으로 변경
         }
         else
         {
            int arr = findDt(currentPoint, redPoint, colorMapping[5][5]); // 오류 안 나나?
            gotoNextRedpatch(arr, currentPoint, redPoint);
            currentPoint = redPoint; // 맞나욘
         }
      }
   }
*/
// 나 울고싶어 얘들아 ㅎㅎ 이 코드 망했어욘 ㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎ

   
   //redPoint location store.
   ff();

   
}
