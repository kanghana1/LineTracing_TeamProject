#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          lm,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          rm,	    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#define MAX_POINTS 100 // max points
#define MAX_DISTANCE 1000000000 // max distance
#define INF 987654321


typedef struct Point {
   int r;
   int c;
   float v;
} Point;

void initPoint(Point point, int ir, int ic, float iv) // Point 변수 초기화 함수
{
   point.r = ir;
   point.c = ic;
   point.v = iv;
}
Point currentPoint; // 현재 위치
Point FinishPoint;
Point redPoint; // 최단거리 레드패치 찾는 걸로 초기화를 해줘야함
int redCount = 0;
int Qmap[5][5];
int colorMapping[5][5]; // 본래맵
Point finalQmap[5][5]; // 최종 큐 맵
// int redPatchMap[5][5]; // 레드패치맵
>>>>>>> 0cb1e2c6871e1cd1c0c70ad91107c2093458d845
/*
float Calculate(Point point1, Point point2){ // calculating distance
   return abs((point1.r + point1.c) - (point2.r + point2.c));
}

int min(int a, int b)
{
   return a < b ? a : b;
}
<<<<<<< HEAD
*/
Point max(Point a, Point b) // 큰 Point 변수 반환.
{
   if(a.v > b.v) return a;
   else return b;
}


/*
=======


>>>>>>> 0cb1e2c6871e1cd1c0c70ad91107c2093458d845
Point minPoint(Point point1, Point point2) {
   Point result;
   result.r = min(point1.r, point2.r);
   result.c = min(point1.c, point2.c);
   return result;
}

Point maxPoint(Point point1, Point point2) {
   Point result;
   result.r = max(point1.r, point2.r);
   result.c = max(point1.c, point2.c);
   return result;
}


Point findShortestDistance(Point currentPosition, Point redPoint[], int redPointCount){ // send redPoint array. compare each elements
	float shortestDistance = MAX_DISTANCE;
	Point shortest_redPatch;

	for (int i = 0; i < redPointCount; i++){
		float distance = Calculate(currentPosition, redPoint[i]);
		if (distance <= shortestDistance) {
			shortestDistance = distance;
			shortest_redPatch.r = redPoint[i].r;
			shortest_redPatch.c = redPoint[i].c;
		}
	}

	return shortest_redPatch; // it returns shortest_redPatch location x, y
}
*/

<<<<<<< HEAD
=======
// int isSafe(int row, int col, int array[5][5], int visited[5][5]) { // 갈 수 있는 곳인지 판별하는 함수
//     return (row >= 0) && (row < 5) && (col >= 0) && (col < 5) && // 좌표가 범위 내에 있고,
//            (array[row][col] != -1) && !visited[row][col]; // 장애물(-1)이 없는지
// }

Point max(Point a, Point b) // 큰 Point 변수 반환.
{
   if(a.v > b.v) return a;
   else return b;
}

>>>>>>> 0cb1e2c6871e1cd1c0c70ad91107c2093458d845
int isPointZero(Point point){ // judging, is it 0, 0.
   return (point.r == 0 && point.c == 0);
}

// int isSafe(int row, int col, int array[5][5], int visited[5][5]) { // 갈 수 있는 곳인지 판별하는 함수
//     return (row >= 0) && (row < 5) && (col >= 0) && (col < 5) && // 좌표가 범위 내에 있고,
//            (array[row][col] != -1) && !visited[row][col]; // 장애물(-1)이 없는지
// }

Point oneQmap(Point p1) { // 예를 들어 레드포인트가 0,1 일 떄
	Point QMap[5][5]; // 큐맵 중 한 개

	for (int i = 0 ; i < 5 ; i++) { // 파란점 외에는 0으로 초기화
		for (int j = 0 ; j < 5 ; j++) {
			if (colorMapping[i][j] == -1) QMap[i][j].v = -1; 
			else QMap[i][j].v = 0;
		}
	}
	QMap[p1.r][p1.c].v = 1; // 레드포인트 한 개만 넣기

	for (int i = 0 ; i < 5 ; i++) {
		for (int j = 0 ; j < 5 ; j++) {
			if (QMap[i][j].v == 0) { 
				if (abs(p1.r - i) + abs(p1.c - j) == 1) {
					QMap[i][j].v = 0.9;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 2) {
					QMap[i][j].v = 0.72;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 3) {
					QMap[i][j].v = 0.5;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 4) {
					QMap[i][j].v = 0.3;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 5) {
					QMap[i][j].v = 0.15;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 6) {
					QMap[i][j].v = 0.06;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 7) {
					QMap[i][j].v = 0.02;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 8) {
					QMap[i][j].v = 0.004;
				}
			}
		}
	}
	return QMap;
}

// Q sum method.
void sumQmap(Point redP)
{
   for(int i=0; i<redCount; i++) // 레드패치 수만큼 반복
   {
      Point arrayQ[5][5] = oneQmap(redP);
      for(int j=0; j<5; j++) // 토탈 Q 맵에 모든 레드패치맵 값 더하기
      {
         for(int k=0; k<5; k++)
         {
            Qmap[j][k] += arrayQ[j][k].v;
         }
      }
   }
}

int derectionNext(Point start, Point end) // 이동해야할 방향을 잡아준다. goNextPoint 함수랑 같이 보면 이해가 쉬워요~
{
   if(abs(start.r + start.c) - abs(end.r + end.c) > 0) // 아래 or 오른쪽으로
   {
      if(start.r < end.r) return 2;// 아래라면
      else return 4; // 오른쪽이라면
   }
   else // 위로 or 왼쪽으로
   {
      if(start.r > end.r) return 1; // 위라면
      else return 3; // 왼쪽이라면
   }
}

void goNextPoint(int derection) // 전달받은 방향을 이용해 이동
{
   if(derection==1) goUp();
   else if(derection==2) godown();
   else if(derection==3) godown();
   else if(derection==4) godown();
   else return;
}


Point oneQmap(Point p1) { // 예를 들어 레드포인트가 0,1 일 떄
	Point QMap[5][5]; // 큐맵 중 한 개

	for (int i = 0 ; i < 5 ; i++) { // 파란점 외에는 0으로 초기화
		for (int j = 0 ; j < 5 ; j++) {
			if (colorMapping[i][j] == -1) QMap[i][j].v = -1; 
			else QMap[i][j].v = 0;
		}
	}
	QMap[p1.r][p1.c].v = 1; // 레드포인트 한 개만 넣기

	for (int i = 0 ; i < 5 ; i++) {
		for (int j = 0 ; j < 5 ; j++) {
			if (QMap[i][j].v == 0) { 
				if (abs(p1.r - i) + abs(p1.c - j) == 1) {
					QMap[i][j].v = 0.9;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 2) {
					QMap[i][j].v = 0.72;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 3) {
					QMap[i][j].v = 0.5;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 4) {
					QMap[i][j].v = 0.3;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 5) {
					QMap[i][j].v = 0.15;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 6) {
					QMap[i][j].v = 0.06;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 7) {
					QMap[i][j].v = 0.02;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 8) {
					QMap[i][j].v = 0.004;
				}
			}
		}
	}
	return QMap; // 타입 다른 이유 설명해주실분 ~^^ 9함~~~~
}

// Q sum method.
void sumQmap(Point redArr[]) {

   for(int i=0; i < redCount; i++) {// 레드패치 수만큼 반복
      Point p = redArr[i];
      Point arrayQ[5][5] = oneQmap(p);

      for(int j=0; j<5; j++) {// 토탈 Q 맵에 모든 레드패치맵 값 더하기
         for(int k=0; k<5; k++) {
            finalQmap[j][k].r = j;
            finalQmap[j][k].c = k;
            finalQmap[j][k].v += arrayQ[j][k].v;
         }
      }
   }
}




void gotoBigQWeight()
{
   Point next; // 큰 값의 포인트가 들어감
   while(currentPoint.r != 0 && currentPoint.c != 0)
   {
      Point up = {currentPoint.r-1, currentPoint.c}; // 상방향
      Point down = {currentPoint.r+1, currentPoint.c}; // 하방향
      Point left = {currentPoint.r, currentPoint.c-1}; // 좌방향
      Point right = {currentPoint.r, currentPoint.c+1}; // 우방향

      /* 만약 {} 초기화 불가면 사용 예정
      initPoint(up, currentPoint.r-1, currentPoint.c, 0);
      initPoint(down, currentPoint.r+1, currentPoint.c, 0);
      initPoint(left, currentPoint.r, currentPoint.c-1, 0);
      initPoint(right, currentPoint.r, currentPoint.c+1, 0);
      */

      if(currentPoint.r == 4 || currentPoint.c == 4) // 행, 열 중 하나가 4라면
      {
         if(currentPoint.r == 4 && currentPoint.c == 4) // 행, 열 둘 다 4라면,
         {
            next = max(up, left); // 위,왼쪽 비교. ex {4, 3}.
            int derec = derectionnext(currentPoint, next); // derec는 방향 잡기
            currentPoint = next; // 현재위치 갱신
            goNextPoint(derec); // 이동
         }
         else if(currentPoint.r == 4) // 행만 4라면,
         {
            next = max(max(up, left), right); // 위, 왼쪽, 오른쪽 비교. 
            int derec = derectionnext(currentPoint, next); // derec는 방향 잡기
            currentPoint = next; // 현재위치 갱신
            goNextPoint(derec);
         }
         else //  if(currentPoint.c == 4) 열만 4라면,
         {
            next = max(max(up, down), left); // 위, 아래, 왼쪽 비교.
            int derec = derectionnext(currentPoint, next); // derec는 방향 잡기
            currentPoint = next; // 현재위치 갱신
            goNextPoint(derec);
         }
      }
      else if(currentPoint.r == 0 || currentPoint.c == 0) // 행, 열 중 하나가 0이라면,
      {
         if(currentPoint.r == 0) // 행이 0이라면,
         {
            next = max(max(down, left), right); // 아래, 왼쪽, 오른쪽 비교. 
            int derec = derectionnext(currentPoint, next);
            currentPoint = next;
            goNextPoint(derec);
         }
         else // 열이 0이라면,
         {
            next = max(max(up, down), right); // 위, 아래, 오른쪽 비교. 
            int derec = derectionnext(currentPoint, next);
            currentPoint = next;
            goNextPoint(derec);
         }
      }
      else // 행, 열이 0 or 4가 아니라면
      {
         next = max(max(up, down), max(left ,right)); // 모든방향(위, 아래, 왼쪽, 오른쪽) 비교. 
         int derec = derectionnext(currentPoint, next);
         currentPoint = next;
         goNextPoint(derec);
      }
   }
   return;
}

// This method calculates the weight from the current location to the red patch located
//  at the shortest distance to helps the robot achieve optimal movement.
<<<<<<< HEAD
=======

>>>>>>> 0cb1e2c6871e1cd1c0c70ad91107c2093458d845
/*
int findDt(Point start, Point end, int arr[5][5])
{ // !! S: information about the patch, Dt: information about weights.

   Point Small, Large;
   int Small_r, Small_c, Large_r, Large_c;
   
   Small = minPoint(start, end); // (자른 배열의 시작지점 구하기)
   Large = maxPoint(start, end); // (자른 배열의 끝지점 구하기)

   Small_r = Small.r;
   Small_c = Small.c;
   Large_r = Large.r;
   Large_c = Large.c;

   Point array_Start = {Small_r, Small_c}; // start point of the original array (본래 배열의 시작지점)
   Point array_End = {Large_r, Large_c}; // end point of the original array (본래 배열의 끝지점)

   int size_r = abs(start.r - end.r) + 1; // array r_size (자른 배열의 r사이즈)
   int size_c = abs(start.c - end.c) + 1; // array c_size (자른 배열의 c사이즈)

   int smallDt[size_r][size_c]; // define small_array of Dt (가중치 배열인 Dt 선언)
   int smallS[size_r][size_c]; // define small_array of S (패치의 위치 배열인 S 선언)

   for (int i = 0; i < size_r; i++) // Bring the patch of original array. In smallS
   {                                // (smallS에다가 자른 배열만큼에 해당하는 본래의 패치 정보를 불러옴)
      for (int j = 0; j < size_c; j++)
      {
         smallS[i][j] = arr[array_Start.r + i][array_Start.c + j]; // 본래의 배열에서 시작지점부터 불러옴
      }
   }


   if(start.r > end.r && start.c > end.c) // direction Left and Up (왼쪽, 위 이동할때의 가중치계산)
   {
      for(int i=start.r; i>=end.r; i--) // Weight calculation about small array.
	   {
		   for(int j=start.c; j>=end.c; j--)
			   {
			   if(i==start.r && j==start.c) smallDt[i][j] = smallS[i][j];
			   else if(i==start.r) smallDt[i][j] = smallDt[i][j+1] + smallS[i][j]; // 왼쪽 방향 가중치
			   else if(j==start.c) smallDt[i][j] = smallDt[i+1][j] + smallS[i][j]; // 위쪽방향 가중치
			   else smallDt[i][j] = max(smallDt[i+1][j], smallDt[i][j+1]) + smallS[i][j];
		   	}
	   }
   }
   else if(start.r > end.r) // direction Up and... (위쪽으로 이동할 건데..)
   {
      if(start.c < end.c) // direction Up and Right (오른쪽으로도 갈 때의 가중치 계산)
      {
         for(int i=start.r; i>=end.r; i--)
	      {
		      for(int j=start.c; j<=end.c; j++)
			      {
			      if(i==start.r && j==start.c) smallDt[i][j] = smallS[i][j];
			      else if(i==start.r) smallDt[i][j] = smallDt[i][j-1] + smallS[i][j]; // 오른쪽 방향 가중치
			      else if(j==start.c) smallDt[i][j] = smallDt[i+1][j] + smallS[i][j]; // 위쪽 방향 가중치
			      else smallDt[i][j] = max(smallDt[i+1][j], smallDt[i][j-1]) + smallS[i][j];
		   	   }
	      }
      }
      else // start.c==end.c. because of (start.r > end.r) is included Left and Up. direction Up.
      {    // (이건 무조건 start.c==end.c. (start.c > end.c)는 이미 위 if문에 (왼쪽, 위) 이동에 포함되어있기 때문. 위쪽으로만의 가중치 계산)
         for(int i=start.r; i>=end.r; i--)
	      {
		      for(int j=start.c; j<=end.c; j--)
			      {
			      if(i==start.r && j==start.c) smallDt[i][j] = smallS[i][j];
			      else smallDt[i][j] = smallDt[i+1][j] + smallS[i][j];
		   	   }
	      }
      }
   }
   else if(start.r < end.r) // direction down and Left (아래로 가면서 왼쪽으로 갈 때의 가중치 계산)
   {                        // 오른쪽만 가거나, 아래만 가거나, (오른쪽, 아래)로 가는 경우의 수는 존재할 수 없다.
      for(int i=start.r; i<=end.r; i++) // Weight calculation about small array.
	   {
		   for(int j=start.c; j>=end.c; j--)
			   {
			   if(i==start.r && j==start.c) smallDt[i][j] = smallS[i][j];
			   else if(i==start.r) smallDt[i][j] = smallDt[i][j+1] + smallS[i][j]; // 왼쪽 방향 가중치
			   else if(j==start.c) smallDt[i][j] = smallDt[i-1][j] + smallS[i][j]; // 아래쪽 방향 가중치
			   else smallDt[i][j] = max(smallDt[i-1][j], smallDt[i][j+1]) + smallS[i][j];
		   	}
	   }
   }
   else // start.r == end.r direction Left (왼쪽으로만 갈 때의 가중치 계산)
   {
      for(int i=start.r; i>=end.r; i--) // Weight calculation about small array.
	   {
		   for(int j=start.c; j>=end.c; j--)
			   {
			   if(i==start.r && j==start.c) smallDt[i][j] = smallS[i][j];
			   else smallDt[i][j] = smallDt[i][j+1] + smallS[i][j];
		   	}
	   }
   }


   if (smallDt[end.r][end.c] > 0) // (도착지점의 가중치가 양수면 배열 반환)
   {
      return smallDt; // return an array of weights to go from (start point) to (end point)
   }
   else if(smallDt[end.r][end.c] == 0)
   {
      return 1; // 1인 이유는 main에서 설명
   }
   else
   {
      return 0; // False. Don't visit this redPatch
   }
}
<<<<<<< HEAD
void gotoNextRedpatch(int dt[5][5], Point start_p, Point end_p)
{
   int start_r = start_p.r;
   int start_c = start_p.c;
   int end_r = end_p.r;
   int end_c = end_p.c;

   while(start_r != end_r && start_c != end_c)
	{
      if(start_r > end_r && start_c > end_c) // move (left)+(up)
      {
         if(dt[start_r-1][start_c] > dt[start_r][start_c-1]) // Left is bigger than Up
         {
            start_c -= 1; // goLeft
            // 왼쪽으로 이동하는 함수 부르기
         }
         else if(dt[start_r-1][start_c] < dt[start_r][start_c-1]) // Up is bigger than Left
         {
            start_r -= 1; // goUp
            // 위쪽으로 이동하는 함수 부르기
         }
         else // if (Left, Up) is same?????
         {
            start_c -= 1; // goLeft
            // 왼쪽으로 이동하는 함수 부르기
         }
      }
		else if(start_r > end_r) // move Up... 위쪽으로 갈 건데...
      {
         if(start_c < end_c) // 오른쪽으로 가야하면
         {
            if(dt[start_r-1][start_c] < dt[start_r][start_c+1]) // 오른쪽 이동
            {
               start_c += 1; // goRight
               // 오른쪽으로 이동하는 함수 부르기
            }
            else if(dt[start_r-1][start_c] > dt[start_r][start_c+1]) // 위쪽 이동
            {
               start_r -= 1; // goUp
               // 위쪽으로 이동하는 함수 부르기
            }
            else
            {
               start_c += 1; // goRight
               // 오른쪽으로 이동하는 함수 부르기
            }
         }
         else
         {
            start_r -= 1; // goUp
         }
      }
      else if(start_r < end_r) // 왼쪽 아래로
      {
         if(dt[start_r-1][start_c] > dt[start_r][start_c-1])
         {
            start_c -= 1; // goLeft
            // 왼쪽으로 이동하는 함수 부르기
         }
         else if(dt[start_r-1][start_c] < dt[start_r][start_c+1])
         {
            start_r += 1; // goRight
            // 오른쪽으로 이동하는 함수 부르기
         }
      }
      else // 왼쪽으로만
      {
         start_c -= 1;
         // 왼쪽으로 이동하는 함수 부르기
      }

		eraseDisplay();

	}
}
*/


=======


*/

>>>>>>> 0cb1e2c6871e1cd1c0c70ad91107c2093458d845
/*
Point RightUpredPatch() // 맨오른쪽아래 빨간점 위치 반환
{
   Point redlast = {-1, -1};
   for (int i = 0; i < 5; ++i) {
      for (int j = 0; j < 5; ++j) {
         if (redPatchMap[i][j] == 1) { // 마지막 빨간점의 인덱스 찾기
            redlast.r = i;
            redlast.c = j;
         }
      }
   }
   return redlast;
}

int redisIn()
{
   int cnt = 0;
   for(int i=0; i<5; i++)
   {
      for(int j=0; j<5; j++)
      {
         if(colorMapping[i][j] == 1)
         {
            cnt += 1;
         }
      }
   }
   return cnt;
}
*/

*/
int derectionNext(Point start, Point end) // 이동해야할 방향을 잡아준다. goNextPoint 함수랑 같이 보면 이해가 쉬워요~
{
   if(abs(start.r + start.c) - abs(end.r + end.c) > 0) // 아래 or 오른쪽으로
   {
      if(start.r < end.r) return 2;// 아래라면
      else return 4; // 오른쪽이라면
   }
   else // 위로 or 왼쪽으로
   {
      if(start.r > end.r) return 1; // 위라면
      else return 3; // 왼쪽이라면
   }
}


void goNextPoint(int derection) // 전달받은 방향을 이용해 이동
{
   if(derection==1) goUp();
   else if(derection==2) godown();
   else if(derection==3) godown();
   else if(derection==4) godown();
   else return;
}




void gotoBigQWeight()
{
   initPoint(currentPoint, 0, 0, 0);
   initPoint(FinishPoint, 4, 4, 0);
   int k = 0;
   Point redPatch[redCount];

   for (int i = 0; i < 5; ++i) {
      for (int j = 0; j < 5; ++j) {
         if (colorMapping[i][j] == 1) { // 컬러맵에서 1이 있으면 그 위치에 똑같이 레드패치맵에 1넣기
            redPatch[k].r = i;
            redPatch[k].c = j;
            redPatch[k].v = 1; // 혹시 오류날까봐 넣음
            k += 1;
         }
      }
   }


<<<<<<< HEAD
=======

>>>>>>> 0cb1e2c6871e1cd1c0c70ad91107c2093458d845
/*
   while(currentPoint.r != 0 && currentPoint.c != 0)
   {
      if(redCount == 0) // 레드패치수가 0개면
      {
         mapsize_r = abs(currentPoint.r- FinishPoint.r) + 1;
         mapsize_c = abs(currentPoint.c- FinishPoint.c) + 1;
         int arr[mapsize_r][mapsize_c] = findDt(currentPoint, FinishPoint, colorMapping); // 오류 안 나나??
         gotoNextRedpatch(arr, currentPoint, FinishPoint);
      }
      else if(redCount > 0) // 레드패치수가 0보다 크면
      {
         redPoint = findShortestDistance(currentPoint, redPatch, redCount); // 다음 레드패치 위치 구하기
         if (redisIn() == 0) // 만약 패치수는 많은데, 맵에 1이 없다면?
         {
            Point RightUpredPoint = RightUpredPatch(); // 맨오른쪽아래 레드패치지점
         }
         else if(findDt(currentPoint, redPoint, colorMapping) == 0) // 반환값이 0이면(가중치가 음수)
         {
            colorMapping[redPoint.r][redPoint.c] = -1; // 패치맵에서 빨간지점 패치값 -1로 변경
            redPatchMap[redPoint.r][redPoint.c] = 0; // 레드 패치맵에서 그 지점 패치값 없애기
            k -= 1;
         }
         else if(findDt(currentPoint, redPoint, colorMapping) == 1) // 반환값이 1이면(가중치가 0)
         {
            colorMapping[redPoint.r][redPoint.c] = 0; // 패치맵에서 빨간지점 패치값 0으로 변경
         }
         else
         {
            int arr = findDt(currentPoint, redPoint, colorMapping[5][5]); // 오류 안 나나?
            gotoNextRedpatch(arr, currentPoint, redPoint);
            currentPoint = redPoint; // 맞나욘
         }
      }
   }
*/
// 나 울고싶어 얘들아 ㅎㅎ 이 코드 망했어욘 ㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎ

   //redPoint location store.
   ff();

<<<<<<< HEAD
}
=======
   
}
>>>>>>> 0cb1e2c6871e1cd1c0c70ad91107c2093458d845
