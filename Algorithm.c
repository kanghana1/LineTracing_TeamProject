#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          lm,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          rm,	    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#define MAX_POINTS 100 // max points
#define MAX_DISTANCE 1000000000 // max distance
#define INF 987654321


typedef struct Point {
   int r;
   int c;
   float v;
} Point;

void initPoint(Point point, int ir, int ic, float iv) // initialize Point variable function
{
   point.r = ir;
   point.c = ic;
   point.v = iv;
}
Point currentPoint;
Point FinishPoint;
Point redPoint; 
int redCount = 0; // count red point
int colorMapping[5][5];
Point finalQmap[5][5]; // total Q map
int score = 0;


Point max(Point a, Point b) // return max point
{
   if(a.v > b.v) return a;
   else return b;
}

int isPointZero(Point point){ // judging, is it 0, 0.
   return (point.r == 0 && point.c == 0);
}

Point** oneQmap(Point p1) { 
	Point QMap[5][5]; 

	for (int i = 0 ; i < 5 ; i++) { //  initalized to 0 excluding the blue point. 
		for (int j = 0 ; j < 5 ; j++) {
			if (colorMapping[i][j] == -1) QMap[i][j].v = -1; 
			else QMap[i][j].v = 0;
		}
	}
	QMap[p1.r][p1.c].v = 1; // input redpoint 

	for (int i = 0 ; i < 5 ; i++) {
		for (int j = 0 ; j < 5 ; j++) {
         QMap[i][j].r = i; // defense null
         QMap[i][j].c = j; // defense null
			if (QMap[i][j].v == 0) { 
				if (abs(p1.r - i) + abs(p1.c - j) == 1) {
					QMap[i][j].v = 0.9;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 2) {
					QMap[i][j].v = 0.72;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 3) {
					QMap[i][j].v = 0.5;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 4) {
					QMap[i][j].v = 0.3;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 5) {
					QMap[i][j].v = 0.15;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 6) {
					QMap[i][j].v = 0.06;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 7) {
					QMap[i][j].v = 0.02;
				}
				else if (abs(p1.r - i) + abs(p1.c - j) == 8) {
					QMap[i][j].v = 0.004;
				}
			}
		}
	}
	return QMap;
}

// Q sum method.
void sumQmap(Point redArr[]) {

   for(int i = 0; i < redCount; i++) {// repeat redPatch length
      Point p = redArr[i];
      Point arrayQ[5][5] = oneQmap(p);

      for(int j=0; j<5; j++) {// add all weights and make finalQmap
         for(int k=0; k<5; k++) { 
            finalQmap[j][k].r = j;
            finalQmap[j][k].c = k;
            finalQmap[j][k].v += arrayQ[j][k].v;
         }
      }
   }
}




void gotoBigQWeight() // move and count score
{  
   Point next; // store next point
   while(currentPoint.r != 0 && currentPoint.c != 0)
   {
      Point up = {currentPoint.r-1, currentPoint.c, finalQmap[currentPoint.r-1][currentPoint.c].v}; // 상방향
      Point down = {currentPoint.r+1, currentPoint.c, finalQmap[currentPoint.r+1][currentPoint.c].v}; // 하방향
      Point left = {currentPoint.r, currentPoint.c-1, finalQmap[currentPoint.r][currentPoint.c-1].v}; // 좌방향
      Point right = {currentPoint.r, currentPoint.c+1, finalQmap[currentPoint.r][currentPoint.c+1].v}; // 우방향

      /* if {} can't initialize, we used it.
      initPoint(up, currentPoint.r-1, currentPoint.c, 0);
      initPoint(down, currentPoint.r+1, currentPoint.c, 0);
      initPoint(left, currentPoint.r, currentPoint.c-1, 0);
      initPoint(right, currentPoint.r, currentPoint.c+1, 0);
      */

      if(currentPoint.r == 4 || currentPoint.c == 4) {
         if(currentPoint.r == 4 && currentPoint.c == 4) {
            if (colorMapping[currentPoint.r][currentPoint.c] == 1) score++; 
            next = max(up, left); 
            int derec = derectionnext(currentPoint, next); 
            currentPoint = next; 
            goNextPoint(derec); 
         }
         else if(currentPoint.r == 4) {
            if (colorMapping[currentPoint.r][currentPoint.c] == 1) score++;
            next = max(max(up, left), right);
            int derec = derectionnext(currentPoint, next); 
            currentPoint = next; 
            goNextPoint(derec);
         }
         else {
            if (colorMapping[currentPoint.r][currentPoint.c] == 1) score++;
            next = max(max(up, down), left); 
            int derec = derectionnext(currentPoint, next); 
            currentPoint = next; 
            goNextPoint(derec);
         }
      }
      else if(currentPoint.r == 0 || currentPoint.c == 0) {

         if(currentPoint.r == 0) {
            if (colorMapping[currentPoint.r][currentPoint.c] == 1) score++;
            next = max(max(down, left), right); 
            int derec = derectionnext(currentPoint, next);
            currentPoint = next;
            goNextPoint(derec);
         }
         else if(currentPoint.c == 0) {
            if (colorMapping[currentPoint.r][currentPoint.c] == 1) score++;
            next = max(max(up, down), right); 
            int derec = derectionnext(currentPoint, next);
            currentPoint = next;
            goNextPoint(derec);
         }
      }
      else {
         if (colorMapping[currentPoint.r][currentPoint.c] == 1) score++;
         next = max(max(up, down), max(left ,right)); 
         int derec = derectionnext(currentPoint, next);
         currentPoint = next;
         goNextPoint(derec);
      }
   }
}

Point RightUpredPatch() // 맨오른쪽아래 빨간점 위치 반환
{
   Point redlast = {-1, -1};
   for (int i = 0; i < 5; ++i) {
      for (int j = 0; j < 5; ++j) {
         if (redPatchMap[i][j] == 1) { // 마지막 빨간점의 인덱스 찾기
            redlast.r = i;
            redlast.c = j;
         }
      }
   }
   return redlast;
}

int redisIn()
{
   int cnt = 0;
   for(int i=0; i<5; i++)
   {
      for(int j=0; j<5; j++)
      {
         if(colorMapping[i][j] == 1)
         {
            cnt += 1;
         }
      }
   }
   return cnt;
}
*/

int derectionNext(Point start, Point end) // It determines the direction to move. It is easier to understand when seen together with the goNextPoint function.
{
   if(abs(start.r + start.c) - abs(end.r + end.c) > 0) // under or right
   {
      if(start.r < end.r) return 2;// under
      else return 4; // right
   }
   else // up or left
   {
      if(start.r > end.r) return 1; // up
      else return 3; // left
   }
}

void goNextPoint(int derection) //  move by using direction recieved
{
   if(derection==1) goUp();
   else if(derection==2) godown();
   else if(derection==3) godown();
   else if(derection==4) godown();
   else return;
}


task main() {
   initPoint(currentPoint, 0, 0, 0);
   initPoint(FinishPoint, 4, 4, 0);
   int k = 0;

   for (int i = 0; i < 5; ++i) {
      for (int j = 0; j < 5; ++j) {
         if (colorMapping[i][j] == 1) { 
            redCount++;
         }
      }
   }   
   Point redPatch[redCount]; // store red point

   for (int i = 0; i < 5; ++i) {
      for (int j = 0; j < 5; ++j) {
         if (colorMapping[i][j] == 1) { // input red point in redPatch arr
            redPatch[k].r = i;
            redPatch[k].c = j;
            redPatch[k].v = 1; // depense error
            k += 1;
         }
      }
   }
   sumQmap(redPatch); // make finalQmap
   currentPoint = finalQmap[4][4]; // initialize currentPoint after put all in finalQmap
   gotoBigQWeight();
   displayBigTextLine(1,"score : %d",score);

}
